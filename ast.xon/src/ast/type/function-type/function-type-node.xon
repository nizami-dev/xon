FunctionTypeNode(context) extends TypeNode
  declaredGenerics = context.declaredGenerics()?.DEFINITION_ID().map(\x: x.text) or []
  parameters = context.typeParameters().type().toNodes()
  returnType = context.type().toNode()
  generics= [...$parameters, $returnType]

  infix ==(other TypeNode) = other is FunctionTypeNode and
    $returnType == other.returnType and
    $parameters.length === other.parameters.length and
    $parameters.every(\x, i: x == other.parameters[i])

  useGenericsMap(genericsMap Map<String, TypeNode> = new Map()) = createFunctionType(
      $declaredGenerics,
      $parameters.map(\x: x.useGenericsMap(genericsMap)),
      $returnType.useGenericsMap(genericsMap))

  getGenericsMap(type TypeNode) Map<String, TypeNode>
    if type is not FunctionTypeNode:
      throw Error(`Type "{type.name}" is not an "{$name}" type`)

    if type.parameters.length !== $parameters.length:
      throw Error(`Type "{type.name}" has {type.parameters.length} parameters but this type has {$parameters.length}`)

    entries = $generics
      .map(\x,i: x.getGenericsMap(type.generics[i]).entries())
      .map(\x: Array.from(x))
      .flat()
    return Map<String, TypeNode>(entries)

  toString() String
    declaredGenerics = $declaredGenerics?.join(', ')
    return if declaredGenerics:`<{declaredGenerics}>({$parameters.join(', ')}) {$returnType}`
    else `({$parameters.join(', ')}) {$returnType}`
