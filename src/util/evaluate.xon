import '../issue-service/issue': Issue
import '../lib/core': none, Unknown
import '../tree/expression/array/array-expression-tree': ArrayExpressionTree
import '../tree/expression/expression-tree': ExpressionTree
import '../tree/expression/group/group-expression-tree': GroupExpressionTree
import '../tree/expression/id/id-expression-tree': IdExpressionTree
import '../tree/expression/infix/infix-expression-tree': InfixExpressionTree
import '../tree/expression/literal/literal-expression-tree': LiteralExpressionTree
import '../tree/expression/prefix/prefix-expression-tree': PrefixExpressionTree

_escapeIfString (s Unknown) => String: s is String and #{`\`${s}\``} or s

evaluate (tree ExpressionTree, argsMap = #{{}}) => Unknown
  if !tree: return none
  if tree is ArrayExpressionTree: return tree.parameters.map((x) => evaluate(x.variable))
  if tree is LiteralExpressionTree: return tree.literal.value
  if tree is GroupExpressionTree: return evaluate(tree.expression)
  if tree is InfixExpressionTree
    a = evaluate(tree.left, argsMap)
    b = evaluate(tree.right, argsMap)
    o = tree.name.text == '^' and '**' or tree.name.text
    return eval(#{`${_escapeIfString(a)} ${o} ${_escapeIfString(b)}`})
  if tree is PrefixExpressionTree
    a = evaluate(tree.value, argsMap)
    return eval(#{`${tree.name.text}${_escapeIfString(a)}`})
  if tree is IdExpressionTree
    if #{tree.name.text in argsMap}: return argsMap[tree.name.text]
    Issue.errorFromTree(tree, #{`Undefined key '${tree.name}'`})
  Issue.errorFromTree(tree, 'Unsupported operation')
